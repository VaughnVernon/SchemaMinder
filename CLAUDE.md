# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

The Kalele Domo Schema Registry is a multi-tenant, hierarchical schema management system built on Cloudflare's edge infrastructure. It manages schema lifecycles for distributed systems using a Published Language pattern from Domain-Driven Design.

### Initialization Prompt

```
This is the root of a product codebase. The product is a schema registry. You and I have developed this product together. To get you reacquainted with the product, you will find information about the product in ./CLAUDE.md and the ./docs subdirectory. You should read those documents and also scan the codebase thoroughly to understand what we have already accomplished together. In general it is based on CloudFlare Durable Objects, use of the Durable Objects SQLite database, TypeScript source code, and React.js UI. There is a DSL parser that is generated by pegjs. You should, of course, see ./package.json for all dependencies and how the are used. This includes local servers for CloudFlare developer mode as well as PartyKit and Node.js. Test coverage is determined by vitest. There are ./scripts for complexity metrics and running the DSL parser generator.
```

## Essential Commands

### Initial Setup (First Time)

**Full guide**: [docs/GETTING_STARTED.md](docs/GETTING_STARTED.md)

```bash
# Complete environment setup (interactive)
npm run setup                       # Creates .env.local, prompts for admin credentials, handles ports

# Pre-flight check (validate environment)
npm run preflight                   # Check Node version, ports, dependencies, etc.

# Start all servers
npm run start:all                   # Backend + PartyKit + Frontend

# Create admin user (in another terminal, after backend is running)
npm run create:admin admin@example.com SecurePass123! "Admin User"
```

**Environment Files**:
- `.env` - Base defaults (committed)
- `.env.development` - Dev team defaults (committed)
- `.env.local` - Your personal settings (git-ignored, created by setup)
- `.env.production` - Production template (committed)

### Development
```bash
# Start all services together (recommended)
npm run start:all                   # Backend + PartyKit + Frontend (using concurrently)

# OR start services individually (separate terminals)
npx wrangler dev --port 8789        # Backend API (Cloudflare Worker)
npx partykit dev --port 1999        # Real-time server
npm run dev                         # Frontend development server

# Database initialization
npm run init:database               # Initialize database schema (optional)
npm run init:database my-tenant my-registry  # With custom tenant/registry

# Build and deployment
npm run build                       # Build frontend (generates dist/)
npx wrangler deploy                 # Deploy Worker (NOT pages deploy)
```

### Testing
```bash
# Test execution
npm run test                        # Run tests in watch mode
npm run test:run                    # Run tests once
npm run test:coverage               # Run with coverage report
npm run test:ui                     # Interactive test UI

# Test specific files/patterns
env VITEST_GLOBAL_SETUP="" npx vitest run tests/contexts/EnhancedAuthContext.test.tsx --config vitest.config.ts --run --coverage

# Coverage analysis
npm run coverage:open               # Open HTML coverage report
```

### Code Quality
```bash
npm run lint                        # ESLint
npm run typecheck                   # TypeScript checking
npm run complexity                  # Complexity analysis
npm run generate:pegjs-parser       # Regenerate schema parser
```

## Architecture Overview

### Multi-Tenant Isolation Model
- **Pattern**: `tenantId:registryId` → Unique Durable Object → Isolated SQLite Database
- **Key Principle**: Complete data isolation per tenant-registry combination
- **Implementation**: Cloudflare Workers + Durable Objects + PartyKit real-time

### Core Service Architecture
```
Frontend (React + Vite) ↔ Cloudflare Worker (API) ↔ Durable Objects (Data)
                     ↕
              PartyKit Server (Real-time updates)
```

### Directory Structure
- `src/` - React frontend application
- `functions/` - Cloudflare Worker backend with Durable Objects
- `party/` - PartyKit real-time server
- `tests/` - Comprehensive test suite with 87%+ coverage
- `docs/` - Architecture and user documentation

## Key Architecture Patterns

### Authentication System
- **Basic Auth**: `AuthContext` with login/registration
- **Enhanced Auth**: `EnhancedAuthContext` with advanced features (password reset, session management, RBAC)
- **Middleware**: `AuthMiddleware` for route protection
- **Roles**: guest, viewer, editor, admin with hierarchical permissions
- **Admin Endpoint**: `/api/admin/update-role` - First admin can self-promote without auth, subsequent changes require admin credentials

### Data Flow
- **Frontend**: React hooks (`useSchemaRegistry`, `useRealTimeUpdates`)
- **State Management**: React Context + custom hooks pattern
- **API Client**: `apiClient.ts` handles all backend communication
- **Real-time**: PartyKit WebSocket integration for live updates

### Schema Management
- **Hierarchy**: Products → Domains → Contexts → Schemas → Versions
- **Parser**: PegJS-based schema specification parser
- **Validation**: Multi-layer validation (syntax, semantics, compatibility)
- **Versioning**: Semantic versioning with compatibility checking

## Test Environment

### Configuration
- **Framework**: Vitest with jsdom environment
- **Coverage**: V8 provider with 70%+ thresholds
- **Parallelism**: Disabled for stability (singleThread: true)
- **Retry**: 2 retries for flaky tests

### Test Categories
- **Unit Tests**: Components, services, utilities
- **Integration Tests**: API endpoints, real-time communication
- **Context Tests**: Authentication and state management

### Fetch Mocking Pattern
When testing components that make fetch calls:
```typescript
// Set up fresh fetch mock for each test
beforeEach(() => {
  vi.clearAllMocks();
  vi.stubGlobal('fetch', mockFetch);
  // Configure mock response
});

afterEach(() => {
  vi.restoreAllMocks();
  vi.unstubAllGlobals();
});
```

## Development Patterns

### Component Structure
- **Hooks-first**: Business logic in custom hooks
- **Event Handlers**: Centralized in `appEventHandlers/`
- **Forms**: Controlled components with validation
- **Hierarchy**: Specialized components for tree navigation

### State Management
- **Global State**: React Context for auth, registry data
- **Local State**: useState for UI state
- **Real-time**: WebSocket integration via useRealTimeUpdates

### Error Handling
- **API Errors**: Standardized error responses
- **UI Feedback**: Toast notifications
- **Validation**: Client-side + server-side validation

## Schema Specification Language

The system uses a custom grammar for schema definitions:
```
{typeName} {schemaName} {
  type schemaTypeNameAttribute
  version versionAttribute
  timestamp timestampAttribute

  // Primitive types with optional defaults
  string stringAttribute (= "default")?
  int intAttribute (= 123)?
  boolean booleanAttribute (= true)?

  // Arrays and references
  string[] stringArrayAttribute
  SchemaName schemaReference
  category.SchemaName:1.2.1 versionedReference
}
```

## Health Check Endpoints

The system provides multiple health check endpoints for different monitoring needs:

- **`/health`** - Fastest, Worker-only health check (no database)
- **`/schema-registry/health`** - Alternative Worker health endpoint
- **`/schema-registry/api/health`** - Durable Object health (includes database initialization check)
- **`/schema-registry/api/registry`** - Full registry info with statistics (slowest, most detailed)

**Recommendations:**
- Load balancers: Use `/health`
- Kubernetes liveness: Use `/health`
- Kubernetes readiness: Use `/api/health`
- Monitoring dashboards: Use `/api/registry`

## Important Notes

### Deployment
- This is a **Worker project**, not a Pages project
- Requires Durable Objects (only available in Workers)
- Frontend builds to `dist/` which is served by the Worker

### Multi-tenant Isolation
- Each `tenant:registry` gets its own Durable Object instance
- Complete data separation between tenants
- Zero-config namespace creation

### Real-time Updates
- PartyKit server on port 1999 for WebSocket communication
- Automatic reconnection and state synchronization
- Message types: schema_created, version_updated, etc.

### Testing Considerations
- Tests run sequentially to avoid port conflicts
- Integration tests require API server running
- Mock fetch properly for components making HTTP calls
- Use coverage thresholds to maintain quality